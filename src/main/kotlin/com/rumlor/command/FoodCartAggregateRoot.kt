package com.rumlor.command

import com.rumlor.api.ConfirmOrderCommand
import com.rumlor.api.CreateFoodCartCommand
import com.rumlor.api.DeSelectProductCommand
import com.rumlor.api.SelectProductCommand
import com.rumlor.events.ConfirmedOrderEvent
import com.rumlor.events.DeSelectedProductEvent
import com.rumlor.events.FoodCartCreatedEvent
import com.rumlor.events.SelectedProductEvent
import com.rumlor.exception.ProductDeSelectionException
import org.axonframework.commandhandling.CommandHandler
import org.axonframework.eventsourcing.EventSourcingHandler
import org.axonframework.modelling.command.*
import org.jboss.logging.Logger
import java.util.*
import kotlin.properties.Delegates

@AggregateRoot
open class FoodCartAggregateRoot()  {

    @AggregateIdentifier
    private lateinit var foodCartId: UUID

    @AggregateMember(eventForwardingMode = ForwardMatchingInstances::class)
    private lateinit var products :Set<ProductAggregateMember>

    private var confirmed by Delegates.notNull<Boolean>()

    private val logger:Logger = Logger.getLogger("FoodCartRoot")

    @CommandHandler
    constructor(command: CreateFoodCartCommand):this(){
        logger.info("create food cart command  arrived:$command")
        AggregateLifecycle.apply(FoodCartCreatedEvent(UUID.randomUUID()))
    }


    @CommandHandler
    fun on(selectProductCommand: SelectProductCommand){
        if (confirmed)
            throw IllegalStateException("Can't select product if cart is confirmed")

        if (selectProductCommand.quantity > selectProductCommand.stock)
                throw ProductDeSelectionException("Not enough stock!!")

        logger.info("select product command arrived:$selectProductCommand")
        AggregateLifecycle.apply(SelectedProductEvent(UUID.randomUUID(),foodCartId,selectProductCommand.productId,selectProductCommand.name,selectProductCommand.stock,selectProductCommand.quantity))
    }

    @CommandHandler
    fun on(command:ConfirmOrderCommand){
        logger.info("confirm cart command arrived: $command")
        AggregateLifecycle.apply(ConfirmedOrderEvent(foodCartId))
    }

    @CommandHandler
    fun on(deSelectProductCommand: DeSelectProductCommand) {

        if (confirmed)
            throw IllegalStateException("Can't de-select product if cart is confirmed")

        logger.info("deselect product command arrived: $deSelectProductCommand")
        if (products.map(ProductAggregateMember::productId).contains(deSelectProductCommand.productId))
            AggregateLifecycle.apply(DeSelectedProductEvent(foodCartId,deSelectProductCommand.productId,deSelectProductCommand.quantity))
        else
            throw ProductDeSelectionException()
    }


    //handler for events generated by aggregate
    @EventSourcingHandler
    fun on(event: FoodCartCreatedEvent) {
        logger.info("food cart create event arrived: $event")
        foodCartId = event.foodCardId
        products = HashSet()
        confirmed = false
    }


    //handler for events generated by aggregate
    @EventSourcingHandler
    fun on(event: SelectedProductEvent) {
        logger.info("select product  event sourced event arrived: $event")
        val product = ProductAggregateMember(event.productId,event.stock,event.name,event.quantity)
        products = products.plus(product)
    }

    //handler for events generated by aggregate
    @EventSourcingHandler
    fun on(event: ConfirmedOrderEvent) {
        logger.info("confirm order event sourced event arrived: $event")
        confirmed = true
    }



    @EventSourcingHandler
    fun on(event: DeSelectedProductEvent) {
        logger.info("deselect product  event sourced event arrived: $event")

        if (!products.map {
            it.productId
        }.contains(event.productId))
            throw IllegalStateException("product not found in cart.")

        products = products.filter {
            it.productId != event.productId
        }.toSet()
    }
}